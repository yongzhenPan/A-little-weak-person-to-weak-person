今晚刚刚写完lab1,开始读了一点点lab2的writeup.....
睡觉ing

这两天断断续续搞了gdb的事，简单读了lab2的writeup，读不太明白，又看了网上的一些文章，按着别人的引导来试，才有一点点眉目，汗。。。
主要就是结合可执行文件bomb的汇编代码和用gdb进行调试来解决问题。
用objdump -d name_of_file 将文件转成汇编代码，objdump就是转成汇编的command,-d就是按照功能板块section来安排汇编代码的关键符。
接下来得看看汇编了。

在汇编代码里面，一般一个函数的返回值是放在%eax寄存器里面的（返回值小于等于32位的情况下），在返回值是64位情况下，则是低32位在%eax,高32位在%edx
如果太大则返回指针了。
所以在汇编代码里面，会去修改%eax的值再去执行释放栈帧add esp。
esp从高地址向低地址生长。
ebp是堆栈基地址。

通过phase_3了解了switch结构，jt跳转表数据结构 使用一个间接跳转指令jmp *0x40245(%eax,8),%eax就是index,就是跳转到0x(40245+(%eax)*8)位置取指令
每一个位置就是跳转表的一个程序快元素位置所在。特点是每一个程序块后面，如果本身有break的话，都会再跳转到switch语句结尾处，于是代码区会出现一堆的无条件跳转jmp .L9类似。

phase_4比较复杂，在phase_4里面还调用了func4,先弄清楚func4需要几个参数，在哪几个寄存器里面，这个可以看看在调用函数之前的寄存器使用情况以及函数内部堆栈准备阶段的寄存器使用情况。函数里面有函数的嵌套递归调用，%eax返回值。
test指令的常规用法检测一个数是正数，零或者负数。

又断断续续，今天写了phase_5，看不太明白phase_6,函数调用先对申请栈空间，再对被调用者保存寄存器进行保护，再干自己的事
phase_6一开始的双层循环就看得我一脸懵逼，原来%13是保存了未调用<read_six_numbers>时的%rsp栈顶指针的值，然后后来move %13 %rbp就是在给分界的栈框底指针赋值
gdb break *0x3728793792

又是一天碌碌无为，深夜debug，终于等来一句Congratulations! You've defused the bomb!从今天下午睡完觉一直调phase_6,到现在12点多终于搞完了，可以和bomblab say goodbye了。
还是很开心做（抄）完这个实验的，了解了gdb的一点点皮毛，也算是入个门了，更多是稍微会看汇编代码，了解一些简单的规则和技巧。
