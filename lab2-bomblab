今晚刚刚写完lab1,开始读了一点点lab2的writeup.....
睡觉ing

这两天断断续续搞了gdb的事，简单读了lab2的writeup，读不太明白，又看了网上的一些文章，按着别人的引导来试，才有一点点眉目，汗。。。
主要就是结合可执行文件bomb的汇编代码和用gdb进行调试来解决问题。
用objdump -d name_of_file 将文件转成汇编代码，objdump就是转成汇编的command,-d就是按照功能板块section来安排汇编代码的关键符。
接下来得看看汇编了。

在汇编代码里面，一般一个函数的返回值是放在%eax寄存器里面的（返回值小于等于32位的情况下），在返回值是64位情况下，则是低32位在%eax,高32位在%edx
如果太大则返回指针了。
所以在汇编代码里面，会去修改%eax的值再去执行释放栈帧add esp。
esp从高地址向低地址生长。
ebp是堆栈基地址。

通过phase_3了解了switch结构，jt跳转表数据结构 使用一个间接跳转指令jmp *0x40245(%eax,8),%eax就是index,就是跳转到0x(40245+(%eax)*8)位置取指令
每一个位置就是跳转表的一个程序快元素位置所在。特点是每一个程序块后面，如果本身有break的话，都会再跳转到switch语句结尾处，于是代码区会出现一堆的无条件跳转jmp .L9类似。

phase_4比较复杂，在phase_4里面还调用了func4,先弄清楚func4需要几个参数，在哪几个寄存器里面，这个可以看看在调用函数之前的寄存器使用情况以及函数内部堆栈准备阶段的寄存器使用情况。函数里面有函数的嵌套递归调用，%eax返回值。
test指令的常规用法检测一个数是正数，零或者负数。
